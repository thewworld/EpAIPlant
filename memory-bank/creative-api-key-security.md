# APIå¯†é’¥å®‰å…¨ç®¡ç†è®¾è®¡

ğŸ¨ğŸ¨ğŸ¨ ENTERING CREATIVE PHASE: ARCHITECTURE DESIGN ğŸ¨ğŸ¨ğŸ¨

## é—®é¢˜é™ˆè¿°

EPAIå¹³å°éœ€è¦å®‰å…¨åœ°ç®¡ç†ä¸Dify APIå’ŒOpenAIç­‰å¤–éƒ¨æœåŠ¡äº¤äº’çš„APIå¯†é’¥ã€‚å½“å‰å®ç°ä¸­ï¼ŒAPIå¯†é’¥ä»¥æ˜æ–‡å½¢å¼å­˜å‚¨åœ¨æ•°æ®åº“ä¸­ï¼Œå¹¶åœ¨åº”ç”¨ç¨‹åºå†…éƒ¨æµè½¬ï¼Œå­˜åœ¨æ½œåœ¨çš„å®‰å…¨é£é™©ã€‚å¯†é’¥æ³„éœ²å¯èƒ½å¯¼è‡´æœªæˆæƒè®¿é—®ã€èµ„æºæ»¥ç”¨å’Œæ½œåœ¨çš„è´¢åŠ¡æŸå¤±ã€‚æ­¤å¤–ï¼Œå½“å‰ç³»ç»Ÿç¼ºä¹å¯†é’¥è½®æ¢æœºåˆ¶ï¼Œä½¿å¯†é’¥é•¿æœŸä¿æŒä¸å˜ï¼Œå¢åŠ äº†æ³„éœ²çš„å¯èƒ½æ€§ã€‚

### å…³é”®éœ€æ±‚ï¼š

1. åŠ å¯†å­˜å‚¨APIå¯†é’¥ï¼Œç¡®ä¿æ•°æ®åº“æ³„éœ²æ—¶å¯†é’¥ä¸è¢«ç›´æ¥æš´éœ²
2. å®ç°APIå¯†é’¥çš„å®‰å…¨ä¼ è¾“æœºåˆ¶ï¼Œå‡å°‘ä¸­é—´äººæ”»å‡»é£é™©
3. è®¾è®¡å¯†é’¥è½®æ¢æœºåˆ¶ï¼Œå®šæœŸæˆ–æ ¹æ®æ¡ä»¶è§¦å‘æ›´æ–°å¯†é’¥
4. æä¾›ç»†ç²’åº¦çš„è®¿é—®æ§åˆ¶ï¼Œé™åˆ¶å¯†é’¥çš„ä½¿ç”¨èŒƒå›´å’Œæƒé™
5. å»ºç«‹å®Œå–„çš„å¯†é’¥å®¡è®¡å’Œç›‘æ§æœºåˆ¶ï¼ŒåŠæ—¶å‘ç°å¼‚å¸¸ä½¿ç”¨è¡Œä¸º

## æ¶æ„é€‰é¡¹åˆ†æ

### é€‰é¡¹1ï¼šåº”ç”¨å±‚åŠ å¯†æ–¹æ¡ˆ

**æè¿°**ï¼šåœ¨åº”ç”¨å±‚å®ç°APIå¯†é’¥çš„åŠ å¯†å’Œè§£å¯†ï¼Œä½¿ç”¨å¯¹ç§°åŠ å¯†ï¼ˆå¦‚AESï¼‰å­˜å‚¨å¯†é’¥ï¼ŒåŠ å¯†å¯†é’¥å¯ä»ç¯å¢ƒå˜é‡æˆ–é…ç½®æœåŠ¡è·å–ã€‚

**ä¼˜ç‚¹**ï¼š
- å®ç°ç®€å•ï¼Œä¸ä¾èµ–å¤–éƒ¨æœåŠ¡
- ä¸ç°æœ‰ä»£ç é›†æˆå®¹æ˜“
- å¯¹æ€§èƒ½å½±å“è¾ƒå°
- ä¸éœ€è¦é¢å¤–åŸºç¡€è®¾æ–½

**ç¼ºç‚¹**ï¼š
- åŠ å¯†å¯†é’¥ä»éœ€å®‰å…¨ç®¡ç†
- è¿è¡Œæ—¶å†…å­˜ä¸­çš„å¯†é’¥ä»ä¸ºæ˜æ–‡
- å¯†é’¥è½®æ¢æœºåˆ¶éœ€è¦é¢å¤–å¼€å‘
- åŠ å¯†å¯†é’¥æ³„éœ²ä¼šå¯¼è‡´æ‰€æœ‰APIå¯†é’¥æš´éœ²

**æŠ€æœ¯å¥‘åˆåº¦**ï¼šé«˜
**å¤æ‚åº¦**ï¼šä½
**å®‰å…¨æ€§**ï¼šä¸­

### é€‰é¡¹2ï¼šå¯†é’¥ä¿é™©åº“æœåŠ¡

**æè¿°**ï¼šä½¿ç”¨ä¸“é—¨çš„å¯†é’¥ç®¡ç†æœåŠ¡ï¼ˆå¦‚HashiCorp Vaultæˆ–AWS Key Management Serviceï¼‰æ¥å­˜å‚¨å’Œç®¡ç†APIå¯†é’¥ï¼Œåº”ç”¨ç¨‹åºé€šè¿‡å®‰å…¨APIè°ƒç”¨è·å–å¯†é’¥ã€‚

**ä¼˜ç‚¹**ï¼š
- é«˜çº§å®‰å…¨ç‰¹æ€§ï¼ŒåŒ…æ‹¬åŠ å¯†ã€è®¿é—®æ§åˆ¶å’Œå®¡è®¡
- å†…ç½®å¯†é’¥è½®æ¢å’Œç‰ˆæœ¬æ§åˆ¶åŠŸèƒ½
- æ”¯æŒåŠ¨æ€å¯†é’¥ç”Ÿæˆå’Œä¸´æ—¶å¯†é’¥
- é™ä½äº†åº”ç”¨ç¨‹åºçš„å®‰å…¨è´Ÿæ‹…
- é›†ä¸­åŒ–å¯†é’¥ç®¡ç†ï¼Œä¾¿äºå®¡è®¡å’Œç›‘æ§

**ç¼ºç‚¹**ï¼š
- éœ€è¦éƒ¨ç½²å’Œç»´æŠ¤é¢å¤–çš„åŸºç¡€è®¾æ–½
- å¢åŠ äº†ç³»ç»Ÿå¤æ‚æ€§å’Œè¿ç»´æˆæœ¬
- å¯èƒ½æˆä¸ºæ€§èƒ½ç“¶é¢ˆï¼Œç‰¹åˆ«æ˜¯é«˜é¢‘APIè°ƒç”¨
- å¯¹å¤–éƒ¨æœåŠ¡çš„ä¾èµ–å¢åŠ äº†æ•…éšœç‚¹

**æŠ€æœ¯å¥‘åˆåº¦**ï¼šä¸­
**å¤æ‚åº¦**ï¼šé«˜
**å®‰å…¨æ€§**ï¼šé«˜

### é€‰é¡¹3ï¼šæ··åˆåŠ å¯†ä¸ç¼“å­˜æ–¹æ¡ˆ

**æè¿°**ï¼šç»“åˆåº”ç”¨å±‚åŠ å¯†å’Œæœ¬åœ°ç¼“å­˜ï¼Œä½¿ç”¨åŒé‡åŠ å¯†ä¿æŠ¤å¯†é’¥ï¼ŒåŒæ—¶é€šè¿‡ç¼“å­˜å‡å°‘è§£å¯†æ“ä½œï¼Œå¹¶å®ç°å®šæœŸè½®æ¢æœºåˆ¶ã€‚

**ä¼˜ç‚¹**ï¼š
- æ¯”å•çº¯åº”ç”¨å±‚åŠ å¯†æ›´å®‰å…¨
- æ€§èƒ½ä¼˜äºçº¯å¯†é’¥ä¿é™©åº“æ–¹æ¡ˆ
- ä¸ä¾èµ–å¤–éƒ¨æœåŠ¡ï¼Œå‡å°‘æ•…éšœç‚¹
- æ”¯æŒå¯†é’¥è½®æ¢å’Œç‰ˆæœ¬æ§åˆ¶
- å¯ä»¥åœ¨ç°æœ‰æ¶æ„ä¸Šé€æ­¥å®æ–½

**ç¼ºç‚¹**ï¼š
- ç¼“å­˜å¢åŠ äº†å†…å­˜ä¸­å¯†é’¥æš´éœ²çš„é£é™©
- å¯†é’¥è½®æ¢é€»è¾‘è¾ƒå¤æ‚
- éœ€è¦é¢å¤–çš„å¯†é’¥ç®¡ç†é€»è¾‘
- å®‰å…¨æ€§ä¸å¦‚ä¸“ä¸šå¯†é’¥ç®¡ç†æœåŠ¡

**æŠ€æœ¯å¥‘åˆåº¦**ï¼šé«˜
**å¤æ‚åº¦**ï¼šä¸­
**å®‰å…¨æ€§**ï¼šä¸­åˆ°é«˜

## å†³ç­–

**é€‰æ‹©æ–¹æ¡ˆ**ï¼šé€‰é¡¹3 - æ··åˆåŠ å¯†ä¸ç¼“å­˜æ–¹æ¡ˆ

**ç†ç”±**ï¼š
1. æ··åˆæ–¹æ¡ˆæä¾›äº†å®‰å…¨æ€§å’Œæ€§èƒ½çš„è‰¯å¥½å¹³è¡¡ï¼Œé€‚åˆAPIå¯†é’¥ç®¡ç†çš„éœ€æ±‚ã€‚
2. ä¸éœ€è¦å¼•å…¥å¤–éƒ¨ä¾èµ–æœåŠ¡ï¼Œé™ä½äº†ç³»ç»Ÿå¤æ‚æ€§å’Œè¿ç»´æˆæœ¬ã€‚
3. æ”¯æŒå¯†é’¥è½®æ¢å’Œç‰ˆæœ¬æ§åˆ¶ï¼Œæ»¡è¶³å®‰å…¨æœ€ä½³å®è·µã€‚
4. å¯ä»¥åœ¨ç°æœ‰ç³»ç»Ÿæ¶æ„ä¸Šé€æ­¥å®æ–½ï¼Œä¸éœ€è¦å¤§è§„æ¨¡é‡æ„ã€‚
5. é€šè¿‡ç¼“å­˜æœºåˆ¶ä¼˜åŒ–æ€§èƒ½ï¼Œé€‚åˆé«˜é¢‘APIè°ƒç”¨åœºæ™¯ã€‚
6. åŒé‡åŠ å¯†æä¾›äº†è¶³å¤Ÿå¼ºåº¦çš„å®‰å…¨ä¿éšœï¼Œå³ä½¿æ•°æ®åº“æ³„éœ²ä¹Ÿä¸ä¼šç›´æ¥æš´éœ²APIå¯†é’¥ã€‚

ğŸ¨ CREATIVE CHECKPOINT: æ¶æ„æ–¹æ¡ˆé€‰æ‹©å®Œæˆ

## å®ç°è®¾è®¡

### ç»„ä»¶ç»“æ„

```mermaid
graph TD
    API["APIæ§åˆ¶å™¨"] --> KeyService["å¯†é’¥æœåŠ¡"]
    KeyService --> Encryptor["å¯†é’¥åŠ å¯†å™¨"]
    KeyService --> KeyCache["å¯†é’¥ç¼“å­˜"]
    KeyService --> KeyRotator["å¯†é’¥è½®æ¢å™¨"]
    KeyService --> KeyRepository["å¯†é’¥å­˜å‚¨åº“"]
    KeyRotator --> RotationScheduler["è½®æ¢è°ƒåº¦å™¨"]
    KeyRotator --> SecretGenerator["å¯†é’¥ç”Ÿæˆå™¨"]
    KeyService --> AuditLogger["å®¡è®¡æ—¥å¿—"]
    KeyRepository --> Database["æ•°æ®åº“"]
    API --> UsageMonitor["ä½¿ç”¨ç›‘æ§"]
    UsageMonitor --> AnomalyDetector["å¼‚å¸¸æ£€æµ‹"]
    AnomalyDetector --> AlertSystem["å‘Šè­¦ç³»ç»Ÿ"]
```

### åŠ å¯†ç­–ç•¥è®¾è®¡

```mermaid
graph TD
    PlainKey["æ˜æ–‡APIå¯†é’¥"] --> Layer1["ç¬¬ä¸€å±‚åŠ å¯†<br>AES-256-GCM"]
    Layer1 --> Salt["éšæœºåŠ ç›"]
    Salt --> Layer2["ç¬¬äºŒå±‚åŠ å¯†<br>ç‹¬ç«‹å¯†é’¥HMAC"]
    Layer2 --> EncryptedKey["åŠ å¯†å­˜å‚¨çš„å¯†é’¥"]
    
    DecryptReq["è§£å¯†è¯·æ±‚"] --> Authentication["èº«ä»½éªŒè¯"]
    Authentication --> Authorization["æˆæƒæ£€æŸ¥"]
    Authorization --> Layer2Dec["ç¬¬äºŒå±‚è§£å¯†"]
    Layer2Dec --> Layer1Dec["ç¬¬ä¸€å±‚è§£å¯†"]
    Layer1Dec --> CacheCheck{"ç¼“å­˜ä¸­?"}
    CacheCheck -->|"æ˜¯"| ReturnCached["è¿”å›ç¼“å­˜å¯†é’¥"]
    CacheCheck -->|"å¦"| DecryptAndCache["è§£å¯†å¹¶ç¼“å­˜"]
    DecryptAndCache --> ReturnNew["è¿”å›è§£å¯†å¯†é’¥"]
    
    ReturnCached & ReturnNew --> UsageTrack["è®°å½•ä½¿ç”¨æƒ…å†µ"]
```

### å¯†é’¥è½®æ¢è®¾è®¡

```mermaid
graph TD
    Trigger["è½®æ¢è§¦å‘å™¨"] --> Condition{"æ»¡è¶³æ¡ä»¶?"}
    Condition -->|"å¦"| Wait["ç»§ç»­ç­‰å¾…"]
    Condition -->|"æ˜¯"| Generate["ç”Ÿæˆæ–°å¯†é’¥"]
    Generate --> StoreNewKey["å­˜å‚¨æ–°å¯†é’¥ç‰ˆæœ¬"]
    StoreNewKey --> UpdateReferences["æ›´æ–°å¼•ç”¨"]
    UpdateReferences --> RevokeCheck{"æ’¤é”€æ—§å¯†é’¥?"}
    RevokeCheck -->|"æ˜¯"| Revoke["æ’¤é”€æ—§å¯†é’¥"]
    RevokeCheck -->|"å¦"| Keep["ä¿ç•™æ—§å¯†é’¥<br>ä¸€æ®µæ—¶é—´"]
    Revoke & Keep --> Notify["é€šçŸ¥ç®¡ç†å‘˜"]
    
    subgraph "è½®æ¢è§¦å‘æ¡ä»¶"
    TimeBasedTrigger["åŸºäºæ—¶é—´:<br>æ¯30/60/90å¤©"]
    EventBasedTrigger["åŸºäºäº‹ä»¶:<br>äººå‘˜å˜åŠ¨/æ³„éœ²é£é™©"]
    UsageBasedTrigger["åŸºäºä½¿ç”¨:<br>è°ƒç”¨æ¬¡æ•°é˜ˆå€¼"]
    end
    
    TimeBasedTrigger & EventBasedTrigger & UsageBasedTrigger --> Trigger
```

## å®ç°æŒ‡å—

1. **å¯†é’¥åŠ å¯†æœåŠ¡å®ç°**:
   ```java
   @Service
   public class ApiKeyEncryptionService {
       
       private static final Logger logger = LoggerFactory.getLogger(ApiKeyEncryptionService.class);
       
       @Value("${encryption.master-key}")
       private String masterKeyBase64;
       
       @Value("${encryption.secondary-key}")
       private String secondaryKeyBase64;
       
       private SecretKey masterKey;
       private SecretKey secondaryKey;
       
       @PostConstruct
       public void init() {
           try {
               // è§£ç Base64ç¼–ç çš„å¯†é’¥
               byte[] masterKeyBytes = Base64.getDecoder().decode(masterKeyBase64);
               byte[] secondaryKeyBytes = Base64.getDecoder().decode(secondaryKeyBase64);
               
               // åˆ›å»ºå¯†é’¥è§„èŒƒå¹¶ç”ŸæˆSecretKeyå¯¹è±¡
               masterKey = new SecretKeySpec(masterKeyBytes, "AES");
               secondaryKey = new SecretKeySpec(secondaryKeyBytes, "HmacSHA256");
               
               logger.info("APIå¯†é’¥åŠ å¯†æœåŠ¡åˆå§‹åŒ–æˆåŠŸ");
           } catch (Exception e) {
               logger.error("APIå¯†é’¥åŠ å¯†æœåŠ¡åˆå§‹åŒ–å¤±è´¥", e);
               throw new RuntimeException("æ— æ³•åˆå§‹åŒ–åŠ å¯†æœåŠ¡", e);
           }
       }
       
       /**
        * åŠ å¯†APIå¯†é’¥
        */
       public String encryptApiKey(String plainApiKey) {
           try {
               // ç”ŸæˆéšæœºIV
               byte[] iv = new byte[12]; // GCMæ¨¡å¼æ¨è12å­—èŠ‚IV
               SecureRandom random = new SecureRandom();
               random.nextBytes(iv);
               
               // ç¬¬ä¸€å±‚åŠ å¯† (AES-GCM)
               Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
               GCMParameterSpec gcmSpec = new GCMParameterSpec(128, iv);
               cipher.init(Cipher.ENCRYPT_MODE, masterKey, gcmSpec);
               
               byte[] encryptedKey = cipher.doFinal(plainApiKey.getBytes(StandardCharsets.UTF_8));
               
               // åˆå¹¶IVå’ŒåŠ å¯†æ•°æ®
               byte[] combined = new byte[iv.length + encryptedKey.length];
               System.arraycopy(iv, 0, combined, 0, iv.length);
               System.arraycopy(encryptedKey, 0, combined, iv.length, encryptedKey.length);
               
               // ç¬¬äºŒå±‚åŠ å¯† (HMAC)
               Mac hmac = Mac.getInstance("HmacSHA256");
               hmac.init(secondaryKey);
               byte[] hmacResult = hmac.doFinal(combined);
               
               // åˆå¹¶HMACå’ŒåŠ å¯†æ•°æ®
               byte[] finalResult = new byte[hmacResult.length + combined.length];
               System.arraycopy(hmacResult, 0, finalResult, 0, hmacResult.length);
               System.arraycopy(combined, 0, finalResult, hmacResult.length, combined.length);
               
               // Base64ç¼–ç æœ€ç»ˆç»“æœ
               return Base64.getEncoder().encodeToString(finalResult);
           } catch (Exception e) {
               logger.error("APIå¯†é’¥åŠ å¯†å¤±è´¥", e);
               throw new RuntimeException("åŠ å¯†å¤±è´¥", e);
           }
       }
       
       /**
        * è§£å¯†APIå¯†é’¥
        */
       public String decryptApiKey(String encryptedApiKey) {
           try {
               // è§£ç Base64
               byte[] encryptedData = Base64.getDecoder().decode(encryptedApiKey);
               
               // åˆ†ç¦»HMACã€IVå’ŒåŠ å¯†æ•°æ®
               byte[] expectedHmac = Arrays.copyOfRange(encryptedData, 0, 32); // HMAC-SHA256 = 32å­—èŠ‚
               byte[] combined = Arrays.copyOfRange(encryptedData, 32, encryptedData.length);
               
               // éªŒè¯HMAC
               Mac hmac = Mac.getInstance("HmacSHA256");
               hmac.init(secondaryKey);
               byte[] calculatedHmac = hmac.doFinal(combined);
               
               if (!MessageDigest.isEqual(calculatedHmac, expectedHmac)) {
                   throw new SecurityException("HMACéªŒè¯å¤±è´¥ï¼Œæ•°æ®å¯èƒ½è¢«ç¯¡æ”¹");
               }
               
               // åˆ†ç¦»IVå’ŒåŠ å¯†æ•°æ®
               byte[] iv = Arrays.copyOfRange(combined, 0, 12);
               byte[] cipherText = Arrays.copyOfRange(combined, 12, combined.length);
               
               // è§£å¯†
               Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
               GCMParameterSpec gcmSpec = new GCMParameterSpec(128, iv);
               cipher.init(Cipher.DECRYPT_MODE, masterKey, gcmSpec);
               
               byte[] decryptedBytes = cipher.doFinal(cipherText);
               return new String(decryptedBytes, StandardCharsets.UTF_8);
           } catch (Exception e) {
               logger.error("APIå¯†é’¥è§£å¯†å¤±è´¥", e);
               throw new RuntimeException("è§£å¯†å¤±è´¥", e);
           }
       }
   }
   ```

2. **å¯†é’¥ç¼“å­˜æœåŠ¡å®ç°**:
   ```java
   @Service
   public class ApiKeyCacheService {
       
       private final Cache<String, String> keyCache;
       private final ApiKeyEncryptionService encryptionService;
       private final ApiKeyUsageService usageService;
       
       public ApiKeyCacheService(ApiKeyEncryptionService encryptionService, 
                               ApiKeyUsageService usageService) {
           this.encryptionService = encryptionService;
           this.usageService = usageService;
           
           // åˆ›å»ºå¸¦æœ‰è‡ªåŠ¨è¿‡æœŸçš„ç¼“å­˜
           this.keyCache = Caffeine.newBuilder()
               .expireAfterWrite(30, TimeUnit.MINUTES)  // 30åˆ†é’Ÿåè¿‡æœŸ
               .maximumSize(100)                       // æœ€å¤šç¼“å­˜100ä¸ªå¯†é’¥
               .build();
       }
       
       /**
        * è·å–è§£å¯†åçš„APIå¯†é’¥
        */
       public String getApiKey(Long appId, String encryptedKey) {
           // ä½¿ç”¨åº”ç”¨IDä½œä¸ºç¼“å­˜é”®
           String cacheKey = "apikey:" + appId;
           
           // å°è¯•ä»ç¼“å­˜è·å–
           String plainKey = keyCache.getIfPresent(cacheKey);
           if (plainKey != null) {
               // è®°å½•ä½¿ç”¨æƒ…å†µä½†ä»ç¼“å­˜è¿”å›
               usageService.recordApiKeyUsage(appId);
               return plainKey;
           }
           
           // ç¼“å­˜æœªå‘½ä¸­ï¼Œè§£å¯†å¯†é’¥
           plainKey = encryptionService.decryptApiKey(encryptedKey);
           
           // æ”¾å…¥ç¼“å­˜
           keyCache.put(cacheKey, plainKey);
           
           // è®°å½•ä½¿ç”¨æƒ…å†µ
           usageService.recordApiKeyUsage(appId);
           
           return plainKey;
       }
       
       /**
        * ä½¿å¯†é’¥ç¼“å­˜å¤±æ•ˆ
        */
       public void invalidateCache(Long appId) {
           keyCache.invalidate("apikey:" + appId);
       }
       
       /**
        * æ¸…é™¤æ‰€æœ‰ç¼“å­˜
        */
       public void clearAllCache() {
           keyCache.invalidateAll();
       }
   }
   ```

3. **å¯†é’¥è½®æ¢æœåŠ¡å®ç°**:
   ```java
   @Service
   public class ApiKeyRotationService {
       
       private static final Logger logger = LoggerFactory.getLogger(ApiKeyRotationService.class);
       
       private final DifyAppRepository appRepository;
       private final ApiKeyEncryptionService encryptionService;
       private final ApiKeyCacheService cacheService;
       private final ApiKeyUsageService usageService;
       
       @Value("${apikey.rotation.days:90}")
       private int rotationDaysPeriod;
       
       @Autowired
       public ApiKeyRotationService(DifyAppRepository appRepository,
                                  ApiKeyEncryptionService encryptionService,
                                  ApiKeyCacheService cacheService,
                                  ApiKeyUsageService usageService) {
           this.appRepository = appRepository;
           this.encryptionService = encryptionService;
           this.cacheService = cacheService;
           this.usageService = usageService;
       }
       
       /**
        * å®šæœŸæ£€æŸ¥å¹¶è½®æ¢è¿‡æœŸçš„APIå¯†é’¥
        */
       @Scheduled(cron = "0 0 2 * * ?")  // æ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡Œ
       public void checkAndRotateKeys() {
           logger.info("å¼€å§‹æ£€æŸ¥APIå¯†é’¥è½®æ¢...");
           
           // è®¡ç®—è½®æ¢é˜ˆå€¼æ—¥æœŸ
           LocalDateTime rotationThreshold = LocalDateTime.now().minusDays(rotationDaysPeriod);
           
           try {
               // è·å–éœ€è¦è½®æ¢çš„åº”ç”¨
               List<DifyApp> appsToRotate = appRepository.findByKeyLastRotatedBefore(rotationThreshold);
               
               logger.info("æ‰¾åˆ°{}ä¸ªåº”ç”¨éœ€è¦å¯†é’¥è½®æ¢", appsToRotate.size());
               
               for (DifyApp app : appsToRotate) {
                   rotateApiKey(app);
               }
               
               logger.info("APIå¯†é’¥è½®æ¢å®Œæˆ");
           } catch (Exception e) {
               logger.error("APIå¯†é’¥è½®æ¢è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯", e);
           }
       }
       
       /**
        * æ‰‹åŠ¨è½®æ¢æŒ‡å®šåº”ç”¨çš„APIå¯†é’¥
        */
       @Transactional
       public DifyApp rotateApiKey(DifyApp app) {
           logger.info("è½®æ¢åº”ç”¨ID={}çš„APIå¯†é’¥", app.getId());
           
           try {
               // è§£å¯†å½“å‰å¯†é’¥ä»¥å…è®¸ç³»ç»Ÿç»§ç»­è®¿é—®Dify APIæœåŠ¡
               String currentPlainKey = encryptionService.decryptApiKey(app.getApiKey());
               
               // ä»Dify APIè·å–æ–°å¯†é’¥ï¼ˆæˆ–åœ¨æ­¤ç³»ç»Ÿä¸­ç”Ÿæˆæ–°å¯†é’¥ï¼‰
               String newPlainKey = generateOrRequestNewApiKey(app, currentPlainKey);
               
               // åŠ å¯†æ–°å¯†é’¥
               String newEncryptedKey = encryptionService.encryptApiKey(newPlainKey);
               
               // æ›´æ–°æ•°æ®åº“è®°å½•
               app.setApiKey(newEncryptedKey);
               app.setPreviousApiKey(app.getApiKey()); // ä¿å­˜æ—§å¯†é’¥ä¸€æ®µæ—¶é—´
               app.setKeyLastRotated(LocalDateTime.now());
               app = appRepository.save(app);
               
               // ä½¿ç¼“å­˜å¤±æ•ˆ
               cacheService.invalidateCache(app.getId());
               
               // è®°å½•å®¡è®¡æ—¥å¿—
               logApiKeyRotation(app.getId(), "SCHEDULED");
               
               return app;
           } catch (Exception e) {
               logger.error("è½®æ¢åº”ç”¨ID={}çš„APIå¯†é’¥å¤±è´¥", app.getId(), e);
               throw new RuntimeException("APIå¯†é’¥è½®æ¢å¤±è´¥", e);
           }
       }
       
       /**
        * ç”Ÿæˆæˆ–è¯·æ±‚æ–°çš„APIå¯†é’¥
        * è¿™ä¸ªæ–¹æ³•éœ€è¦æ ¹æ®å®é™…çš„å¯†é’¥è·å–æ–¹å¼å®ç°
        */
       private String generateOrRequestNewApiKey(DifyApp app, String currentKey) {
           // å®ç°ä»Dify APIæœåŠ¡è·å–æ–°å¯†é’¥çš„é€»è¾‘
           // æˆ–è€…åœ¨æœ¬ç³»ç»Ÿä¸­ç”Ÿæˆæ–°çš„å¯†é’¥
           // è¿™é‡Œæ˜¯ä¸€ä¸ªç¤ºä¾‹å®ç°
           return "new-api-key-" + UUID.randomUUID().toString();
       }
       
       private void logApiKeyRotation(Long appId, String reason) {
           // è®°å½•åˆ°å®¡è®¡æ—¥å¿—
       }
   }
   ```

4. **APIå¯†é’¥ä½¿ç”¨å’Œå¼‚å¸¸æ£€æµ‹æœåŠ¡**:
   ```java
   @Service
   public class ApiKeyUsageService {
       
       private static final Logger logger = LoggerFactory.getLogger(ApiKeyUsageService.class);
       
       private final Map<Long, AtomicInteger> dailyUsageCounts = new ConcurrentHashMap<>();
       private final Map<Long, AtomicInteger> hourlyUsageCounts = new ConcurrentHashMap<>();
       private final JdbcTemplate jdbcTemplate;
       
       @Value("${apikey.usage.hourly-threshold:1000}")
       private int hourlyThreshold;
       
       @Autowired
       public ApiKeyUsageService(JdbcTemplate jdbcTemplate) {
           this.jdbcTemplate = jdbcTemplate;
       }
       
       /**
        * è®°å½•APIå¯†é’¥ä½¿ç”¨æƒ…å†µ
        */
       public void recordApiKeyUsage(Long appId) {
           // å¢åŠ ä½¿ç”¨è®¡æ•°
           dailyUsageCounts.computeIfAbsent(appId, k -> new AtomicInteger(0)).incrementAndGet();
           int hourlyCount = hourlyUsageCounts.computeIfAbsent(appId, k -> new AtomicInteger(0)).incrementAndGet();
           
           // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é˜ˆå€¼
           if (hourlyCount > hourlyThreshold) {
               logger.warn("åº”ç”¨ID={}çš„APIå¯†é’¥ä½¿ç”¨é¢‘ç‡å¼‚å¸¸ï¼Œä¸€å°æ—¶å†…å·²ä½¿ç”¨{}æ¬¡", appId, hourlyCount);
               // è§¦å‘å‘Šè­¦æœºåˆ¶
               triggerUsageAlert(appId, hourlyCount);
           }
       }
       
       /**
        * é‡ç½®æ¯å°æ—¶è®¡æ•°å™¨
        */
       @Scheduled(cron = "0 0 * * * ?")  // æ¯å°æ—¶æ‰§è¡Œä¸€æ¬¡
       public void resetHourlyCounters() {
           hourlyUsageCounts.clear();
       }
       
       /**
        * ä¿å­˜æ¯æ—¥ä½¿ç”¨ç»Ÿè®¡å¹¶é‡ç½®è®¡æ•°å™¨
        */
       @Scheduled(cron = "0 0 0 * * ?")  // æ¯å¤©å‡Œæ™¨æ‰§è¡Œ
       public void saveDailyStatistics() {
           LocalDate today = LocalDate.now();
           
           for (Map.Entry<Long, AtomicInteger> entry : dailyUsageCounts.entrySet()) {
               Long appId = entry.getKey();
               int count = entry.getValue().get();
               
               // ä¿å­˜åˆ°æ•°æ®åº“
               jdbcTemplate.update(
                   "INSERT INTO api_key_usage (app_id, usage_date, count) VALUES (?, ?, ?)",
                   appId, today, count
               );
           }
           
           // é‡ç½®æ¯æ—¥è®¡æ•°å™¨
           dailyUsageCounts.clear();
       }
       
       private void triggerUsageAlert(Long appId, int usageCount) {
           // å®ç°å‘Šè­¦é€»è¾‘ï¼Œä¾‹å¦‚å‘é€é‚®ä»¶æˆ–çŸ­ä¿¡
       }
   }
   ```

5. **DifyAppRepository æ‰©å±•**:
   ```java
   @Repository
   public interface DifyAppRepository extends JpaRepository<DifyApp, Long> {
       
       /**
        * æŸ¥æ‰¾éœ€è¦è½®æ¢å¯†é’¥çš„åº”ç”¨
        */
       @Query("SELECT a FROM DifyApp a WHERE a.keyLastRotated < :threshold OR a.keyLastRotated IS NULL")
       List<DifyApp> findByKeyLastRotatedBefore(LocalDateTime threshold);
       
       /**
        * ä¿å­˜å®¡è®¡æ—¥å¿—
        */
       @Modifying
       @Query(value = "INSERT INTO api_key_audit (app_id, action, action_time, action_user, details) VALUES (:appId, :action, :actionTime, :actionUser, :details)", nativeQuery = true)
       void saveAuditLog(@Param("appId") Long appId, @Param("action") String action, @Param("actionTime") LocalDateTime actionTime, @Param("actionUser") String actionUser, @Param("details") String details);
   }
   ```

6. **æ•°æ®æ¨¡å‹æ›´æ–°**:
   ```java
   @Entity
   @Table(name = "dify_app")
   public class DifyApp {
       
       // ç°æœ‰å­—æ®µ...
       
       @Column(name = "api_key", columnDefinition = "TEXT")
       private String apiKey;
       
       @Column(name = "previous_api_key", columnDefinition = "TEXT")
       private String previousApiKey;
       
       @Column(name = "key_last_rotated")
       private LocalDateTime keyLastRotated;
       
       @Column(name = "key_expiry_date")
       private LocalDateTime keyExpiryDate;
       
       // Getterå’ŒSetter...
   }
   ```

7. **æ§åˆ¶å™¨å±‚æ›´æ–°**:
   ```java
   @RestController
   @RequestMapping("/api/admin/api-keys")
   public class ApiKeyAdminController {
       
       private final DifyAppRepository appRepository;
       private final ApiKeyRotationService rotationService;
       private final ApiKeyEncryptionService encryptionService;
       
       @Autowired
       public ApiKeyAdminController(DifyAppRepository appRepository,
                                  ApiKeyRotationService rotationService,
                                  ApiKeyEncryptionService encryptionService) {
           this.appRepository = appRepository;
           this.rotationService = rotationService;
           this.encryptionService = encryptionService;
       }
       
       /**
        * æ‰‹åŠ¨è½®æ¢APIå¯†é’¥
        */
       @PostMapping("/{appId}/rotate")
       public ResponseEntity<DifyApp> rotateApiKey(@PathVariable Long appId) {
           DifyApp app = appRepository.findById(appId)
               .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "æ‰¾ä¸åˆ°åº”ç”¨"));
           
           DifyApp updatedApp = rotationService.rotateApiKey(app);
           
           return ResponseEntity.ok(updatedApp);
       }
       
       /**
        * è®¾ç½®æ–°çš„APIå¯†é’¥
        */
       @PostMapping("/{appId}/set-key")
       public ResponseEntity<DifyApp> setApiKey(@PathVariable Long appId, @RequestBody Map<String, String> request) {
           DifyApp app = appRepository.findById(appId)
               .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "æ‰¾ä¸åˆ°åº”ç”¨"));
           
           String newPlainKey = request.get("apiKey");
           if (StringUtils.isEmpty(newPlainKey)) {
               throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "APIå¯†é’¥ä¸èƒ½ä¸ºç©º");
           }
           
           // åŠ å¯†æ–°å¯†é’¥
           String encryptedKey = encryptionService.encryptApiKey(newPlainKey);
           
           // æ›´æ–°åº”ç”¨
           app.setApiKey(encryptedKey);
           app.setKeyLastRotated(LocalDateTime.now());
           app = appRepository.save(app);
           
           return ResponseEntity.ok(app);
       }
       
       /**
        * è·å–APIå¯†é’¥ä½¿ç”¨ç»Ÿè®¡
        */
       @GetMapping("/{appId}/usage")
       public ResponseEntity<Map<String, Object>> getKeyUsageStats(@PathVariable Long appId,
                                                               @RequestParam(required = false) 
                                                               @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) 
                                                               LocalDate from,
                                                               @RequestParam(required = false) 
                                                               @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) 
                                                               LocalDate to) {
           // å®ç°è·å–ä½¿ç”¨ç»Ÿè®¡æ•°æ®çš„é€»è¾‘
           
           Map<String, Object> result = new HashMap<>();
           // å¡«å……ç»“æœ...
           
           return ResponseEntity.ok(result);
       }
   }
   ```

## éªŒè¯å’Œæ£€æŸ¥ç‚¹

âœ“ **æ¶æ„è®¾è®¡éªŒè¯**
- [x] ä½¿ç”¨åŒå±‚åŠ å¯†ä¿æŠ¤APIå¯†é’¥
- [x] å®ç°äº†å¯†é’¥ç¼“å­˜ä»¥ä¼˜åŒ–æ€§èƒ½
- [x] æ”¯æŒå®šæœŸå’Œæ‰‹åŠ¨å¯†é’¥è½®æ¢
- [x] å¯†é’¥ä½¿ç”¨ç›‘æ§å’Œå¼‚å¸¸æ£€æµ‹
- [x] å®¡è®¡æ—¥å¿—è®°å½•å¯†é’¥æ“ä½œ
- [x] å®‰å…¨ä¼ è¾“ç¡®ä¿å¯†é’¥åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­å—ä¿æŠ¤

âœ“ **å®æ–½å‡†å¤‡å°±ç»ª**
- [x] æ•°æ®æ¨¡å‹è®¾è®¡å·²å®Œæˆ
- [x] ä¸»è¦ç»„ä»¶è®¾è®¡å·²å®Œæˆ
- [x] ä¸ç°æœ‰ç³»ç»Ÿçš„é›†æˆè·¯å¾„æ˜ç¡®
- [x] å¯†é’¥è½®æ¢ç­–ç•¥å·²å®šä¹‰
- [x] å®‰å…¨è€ƒè™‘å·²çº³å…¥è®¾è®¡
- [x] å¼‚å¸¸æ£€æµ‹æœºåˆ¶å·²å®šä¹‰

ğŸ¨ğŸ¨ğŸ¨ EXITING CREATIVE PHASE - DECISION MADE ğŸ¨ğŸ¨ğŸ¨ 